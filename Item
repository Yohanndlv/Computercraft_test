-- Liste des coffres dans l'ordre de priorité (à remplir en premier)
local chestNames = {
    "minecraft:chest_0",
    "minecraft:chest_1",
    "minecraft:chest_2"
    -- ajoute-en autant que nécessaire
}

-- Indexer tous les items avec leur source
local allItems = {}

-- Récupérer tous les items dans tous les coffres
for _, chestName in ipairs(chestNames) do
    local items = peripheral.call(chestName, "list")
    if items then  -- Vérification si des items existent
        for slot, item in pairs(items) do
            table.insert(allItems, {
                name = item.name,
                count = item.count,
                source = chestName,
                slot = slot
            })
        end
    else
        print("Aucun item trouvé dans " .. chestName)
    end
end

-- Trier les items par nom (ordre alphabétique)
table.sort(allItems, function(a, b)
    return a.name < b.name
end)

-- Répartition dans les coffres (en remplissant les premiers coffres)
local currentChestIndex = 1
local currentSlot = 1

for _, item in ipairs(allItems) do
    local placed = false
    while not placed and currentChestIndex <= #chestNames do
        local targetChest = chestNames[currentChestIndex]
        local slot = currentSlot
        
        -- On essaie de pousser l'item dans le coffre
        local pushed = peripheral.call(item.source, "pushItems", targetChest, item.slot)
        
        if pushed > 0 then
            placed = true
        else
            -- Si le coffre est plein, passer au suivant
            print("Le coffre " .. targetChest .. " est plein, essayons avec le suivant.")
            currentChestIndex = currentChestIndex + 1
            currentSlot = 1  -- Réinitialiser le slot pour le prochain coffre
        end
    end
end

print("Tri terminé.")
