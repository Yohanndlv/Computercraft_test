-- Initialisation
local monitor
local chests = {}
local chestNames = {}
local content = {}
local scroll = 0

-- Liaison des p√©riph√©riques
for _, name in ipairs(peripheral.getNames()) do
    local pType = peripheral.getType(name)
    if pType == "monitor" then
        monitor = peripheral.wrap(name)
    elseif pType == "minecraft:chest" then
        local chest = peripheral.wrap(name)
        table.insert(chests, chest)
        table.insert(chestNames, name)
    end
end

if not monitor then
    print("Aucun moniteur d√©tect√©.")
    return
end

monitor.setTextScale(0.5)
monitor.setBackgroundColor(colors.black)
monitor.setTextColor(colors.white)

local w, h = monitor.getSize()
local viewHeight = h
local maxScroll = 0

-- Collecte et tri des objets
local function collectAndSortItems()
    local allItems = {}

    for i, chest in ipairs(chests) do
        local items = chest.list()
        for slot, item in pairs(items) do
            table.insert(allItems, {
                name = item.name,
                count = item.count,
                chestIndex = i,
                chestName = chestNames[i],
                slot = slot
            })
        end
    end

    table.sort(allItems, function(a, b)
        return a.name < b.name
    end)

    return allItems
end

-- Tri et redistribution des objets
local function sortAndRedistributeItems()
    local sorted = collectAndSortItems()

    -- Vider tous les coffres sauf le premier dans un buffer temporaire (coffre[1])
    for i = 2, #chests do
        local chest = chests[i]
        local items = chest.list()
        for slot, _ in pairs(items) do
            chest.pushItems(chestNames[1], slot)
        end
    end

    -- R√©partir les items depuis le buffer
    local buffer = chests[1]
    local bufferName = chestNames[1]
    local bufferItems = buffer.list()

    for slot, item in pairs(bufferItems) do
        local moved = false
        for i = 1, #chests do
            local target = chests[i]
            local size = peripheral.call(chestNames[i], "size")
            local targetItems = target.list()

            if #targetItems < size then
                buffer.pushItems(chestNames[i], slot)
                moved = true
                break
            end
        end

        if not moved then
            print("‚ö†Ô∏è Pas assez d‚Äôespace pour tout trier.")
            break
        end
    end
end

-- G√©n√©ration de l'affichage
local function generateContent()
    content = {}
    for i, chest in ipairs(chests) do
        table.insert(content, "Coffre #" .. i)
        local items = chest.list()
        for _, item in pairs(items) do
            table.insert(content, "- " .. item.count .. "x " .. item.name)
        end
        table.insert(content, "") -- espace entre coffres
    end
    maxScroll = math.max(0, #content - viewHeight + 1)
end

-- Affichage sur le moniteur
local function draw()
    monitor.clear()
    for i = 1, viewHeight do
        local line = content[i + scroll]
        if line then
            monitor.setCursorPos(1, i)
            monitor.write(line:sub(1, w - 2))
        end
    end

    -- Slider √† droite
    local sliderHeight = math.max(1, math.floor(viewHeight * (viewHeight / #content)))
    local sliderPos = math.floor((scroll / maxScroll) * (viewHeight - sliderHeight)) + 1

    for i = 1, viewHeight do
        monitor.setCursorPos(w, i)
        if i >= sliderPos and i < sliderPos + sliderHeight then
            monitor.write("|")
        else
            monitor.write(" ")
        end
    end
end

-- Gestion tactile du slider
local function handleTouch(x, y)
    if x == w then
        local ratio = (y - 1) / (viewHeight - 1)
        scroll = math.floor(ratio * maxScroll + 0.5)
        draw()
    end
end

-- üü¢ Lancement
sortAndRedistributeItems()
generateContent()
draw()

-- Boucle de d√©tection tactile
while true do
    local event, side, x, y = os.pullEvent("monitor_touch")
    handleTouch(x, y)
end
