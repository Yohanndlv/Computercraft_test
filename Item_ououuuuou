-- Liste des coffres dans l'ordre de priorité (à remplir en premier)
local chestNames = {
    "minecraft:chest_0",
    "minecraft:chest_1",
    "minecraft:chest_2"
    -- ajoute-en autant que nécessaire
}

-- Indexer tous les items avec leur source
local allItems = {}

for _, chestName in ipairs(chestNames) do
    local items = peripheral.call(chestName, "list")
    for slot, item in pairs(items) do
        table.insert(allItems, {
            name = item.name,
            count = item.count,
            source = chestName,
            slot = slot
        })
    end
end

-- Trier les items : 1. Par nom (ordre alphabétique), 2. Par quantité (du plus grand au plus petit)
table.sort(allItems, function(a, b)
    if a.name == b.name then
        return a.count > b.count  -- si même nom, on trie par quantité décroissante
    else
        return a.name < b.name  -- sinon on trie par nom (ordre alphabétique)
    end
end)

-- Répartition dans les coffres
local currentChestIndex = 1
local currentSlot = 1

for _, item in ipairs(allItems) do
    local placed = false
    while not placed and currentChestIndex <= #chestNames do
        local targetChest = chestNames[currentChestIndex]
        
        -- Vérifier si le coffre cible a de la place
        local targetChestSpace = peripheral.call(targetChest, "space")
        if targetChestSpace > 0 then
            -- Essayer de déplacer un item du coffre source vers le coffre cible
            local moved = peripheral.call(item.source, "pushItems", targetChest, item.slot, item.count)
            if moved > 0 then
                placed = true
            else
                -- Le transfert a échoué, passer au coffre suivant
                currentChestIndex = currentChestIndex + 1
            end
        else
            -- Si le coffre est plein, on passe au coffre suivant
            currentChestIndex = currentChestIndex + 1
        end
    end
end

print("Tri terminé.")
