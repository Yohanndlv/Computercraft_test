local monitor
local chests = {}
local chestNames = {}
local content = {}
local scroll = 0

-- Lier les p√©riph√©riques
for _, name in ipairs(peripheral.getNames()) do
    local pType = peripheral.getType(name)
    if pType == "monitor" then
        monitor = peripheral.wrap(name)
    elseif pType == "minecraft:chest" then
        local chest = peripheral.wrap(name)
        table.insert(chests, chest)
        table.insert(chestNames, name)
    end
end

if not monitor then
    print("Aucun moniteur trouv√©.")
    return
end

monitor.setTextScale(0.5)
monitor.setBackgroundColor(colors.black)
monitor.setTextColor(colors.white)

local w, h = monitor.getSize()
local viewHeight = h
local maxScroll = 0

-- Fusionne et trie les items
local function collectAndSortItems()
    local allItems = {}

    for i, chest in ipairs(chests) do
        local items = chest.list()
        for slot, item in pairs(items) do
            table.insert(allItems, {
                name = item.name,
                count = item.count,
                chestIndex = i,
                chestName = chestNames[i],
                slot = slot
            })
        end
    end

    table.sort(allItems, function(a, b)
        return a.name < b.name
    end)

    return allItems
end

-- R√©organise les objets entre les coffres
local function sortAndRedistributeItems()
    local sorted = collectAndSortItems()

    -- Vider tous les coffres (en les transf√©rant vers le premier)
    for i = 2, #chests do
        local chest = chests[i]
        local items = chest.list()
        for slot, _ in pairs(items) do
            chest.pushItems(chestNames[1], slot)
        end
    end

    -- Re-distribuer les items tri√©s dans les coffres
    local targetChest = 1
    local targetSlot = 1

    for _, item in ipairs(sorted) do
        -- Extraire depuis le coffre source vers le bon
        local fromChest = peripheral.wrap(item.chestName)
        fromChest.pushItems(chestNames[targetChest], item.slot)

        -- Changer de coffre si le pr√©c√©dent est plein (simpliste)
        targetSlot = targetSlot + 1
        if targetSlot > 27 then
            targetSlot = 1
            targetChest = targetChest + 1
            if targetChest > #chests then
                print("Pas assez d'espace pour tout trier.")
                break
            end
        end
    end
end

-- Met √† jour le contenu affich√©
local function generateContent()
    content = {}
    for i, chest in ipairs(chests) do
        table.insert(content, "Coffre #" .. i)
        local items = chest.list()
        for _, item in pairs(items) do
            table.insert(content, "- " .. item.count .. "x " .. item.name)
        end
        table.insert(content, "") -- ligne vide
    end
    maxScroll = math.max(0, #content - viewHeight + 1)
end

-- Affiche sur le monitor
local function draw()
    monitor.clear()
    for i = 1, viewHeight do
        local line = content[i + scroll]
        if line then
            monitor.setCursorPos(1, i)
            monitor.write(line:sub(1, w - 2))
        end
    end

    -- Dessin du slider
    local sliderHeight = math.max(1, math.floor(viewHeight * (viewHeight / #content)))
    local sliderPos = math.floor((scroll / maxScroll) * (viewHeight - sliderHeight)) + 1

    for i = 1, viewHeight do
        monitor.setCursorPos(w, i)
        if i >= sliderPos and i < sliderPos + sliderHeight then
            monitor.write("|")
        else
            monitor.write(" ")
        end
    end
end

-- Clic tactile sur le slider
local function handleTouch(x, y)
    if x == w then
        local ratio = (y - 1) / (viewHeight - 1)
        scroll = math.floor(ratio * maxScroll + 0.5)
        draw()
    end
end

-- üöÄ Initialisation
sortAndRedistributeItems()
generateContent()
draw()

-- Boucle √©v√©nementielle
while true do
    local event, side, x, y = os.pullEvent("monitor_touch")
    handleTouch(x, y)
end
