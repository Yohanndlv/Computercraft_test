-- === Initialisation ===
local monitor
local chests = {}
local content = {}
local scroll = 0

-- Détection des coffres et du monitor
for _, name in ipairs(peripheral.getNames()) do
    local pType = peripheral.getType(name)
    if pType == "monitor" then
        monitor = peripheral.wrap(name)
    elseif pType == "minecraft:chest" then
        table.insert(chests, peripheral.wrap(name))
    end
end

if not monitor then
    print("Aucun monitor trouvé.")
    return
end

monitor.setTextScale(0.5)
monitor.setBackgroundColor(colors.black)
monitor.setTextColor(colors.white)

local w, h = monitor.getSize()
local viewHeight = h
local maxScroll = 0

-- === Tri alphabétique des objets dans les coffres ===
local function sortItemsAlphabetically()
    -- Récupère les noms des coffres
    local chestNames = {}
    for _, name in ipairs(peripheral.getNames()) do
        if peripheral.getType(name) == "minecraft:chest" then
            table.insert(chestNames, name)
        end
    end

    -- Récupère tous les items
    local allItems = {}
    for _, chestName in ipairs(chestNames) do
        local chest = peripheral.wrap(chestName)
        local items = chest.list()
        for slot, item in pairs(items) do
            table.insert(allItems, {
                name = item.name,
                count = item.count,
                slot = slot,
                fromChest = chestName,
            })
        end
    end

    -- Trie par ordre alphabétique
    table.sort(allItems, function(a, b)
        return a.name < b.name
    end)

    -- Répartit les objets dans les coffres triés
    local chestIndex = 1
    local currentChest = chestNames[chestIndex]
    local currentSlot = 1

    for _, item in ipairs(allItems) do
        if currentSlot > 27 then
            chestIndex = chestIndex + 1
            if chestIndex > #chestNames then
                print("Plus de coffres disponibles pour trier.")
                break
            end
            currentChest = chestNames[chestIndex]
            currentSlot = 1
        end

        if item.fromChest ~= currentChest then
            peripheral.call(item.fromChest, "pushItems", currentChest, item.slot)
            sleep(0.05)
        end

        currentSlot = currentSlot + 1
    end
end

-- === Génère le contenu à afficher dans le monitor ===
local function generateContent()
    content = {}
    for i, chest in ipairs(chests) do
        table.insert(content, "Coffre #" .. i)
        local items = chest.list()
        for _, item in pairs(items) do
            table.insert(content, "- " .. item.count .. "x " .. item.name)
        end
        table.insert(content, "")
    end
    maxScroll = math.max(0, #content - viewHeight + 1)
end

-- === Affiche le contenu et le slider ===
local function draw()
    monitor.clear()
    for i = 1, viewHeight do
        local line = content[i + scroll]
        if line then
            monitor.setCursorPos(1, i)
            monitor.write(line:sub(1, w - 2)) -- laisse la place pour le slider
        end
    end

    -- Slider à droite
    local sliderHeight = math.max(1, math.floor(viewHeight * (viewHeight / #content)))
    local sliderPos = math.floor((scroll / maxScroll) * (viewHeight - sliderHeight)) + 1

    for i = 1, viewHeight do
        monitor.setCursorPos(w, i)
        if i >= sliderPos and i < sliderPos + sliderHeight then
            monitor.write("|")
        else
            monitor.write(" ")
        end
    end
end

-- === Gère le clic sur le monitor ===
local function handleTouch(x, y)
    if x == w then
        local ratio = (y - 1) / (viewHeight - 1)
        scroll = math.floor(ratio * maxScroll + 0.5)
        draw()
    end
end

-- === Boucle principale ===
while true do
    sortItemsAlphabetically()  -- Trie et déplace les objets
    generateContent()          -- Met à jour le contenu
    draw()                     -- Affiche à l'écran

    local timer = os.startTimer(10) -- attend 10s ou un clic
    while true do
        local event, p1, x, y = os.pullEvent()
        if event == "monitor_touch" then
            handleTouch(x, y)
            break
        elseif event == "timer" and p1 == timer then
            break
        end
    end
end
